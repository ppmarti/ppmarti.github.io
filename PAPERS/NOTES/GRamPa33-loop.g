# 22/4/00  2/6/05  8/4/18  (gap4 version, with Brauer)
# Loop braid stuff extracted from PPM's GAP Ramified Partitions macros
# NB this file uses emacs folding mode (but you can ignore it).
#{{{ (-1. Conditional conversion from gap3 to gap4)
#
#conversion from gap3 to gap4
if VERSION[1]='4' then 
    Print("I note that this is Gap4 \n");
    Copy:=function(x)
        return StructuralCopy(x);
    end;
fi;
#}}}
#{{{ NOTES
#
### As usual, run gap then do 
### > Read("GRamPa.g")
### to load this file.
#
# NB KroneckerProduct(mat1,mat2) exists in gap; 
#    ElementaryDivisorsMat(mat) exists for Smith Normal Form, but may only
#    work with mat an integer matrix;
#    DirectSumMat appears to require package CHEVIE (we dont seem to have it).
#
# A Relation record r for a relation r on a set S \subset \N 
# such that the numerically largest element is smax consists of 
# r.indices = S 
# and at least one of
# r.asmatrix = partial binding of smax x smax matrix such that 
#              r.asmatrix[i][j]>0 if irj (NB, not unique)
# r.asembedmatrix = as above but with unbound entries bound to zero 
#
# A Partition record p for a partition p of S consists of 
# the corresponding (equivalence) relation record and
# p.aspartition = p as a partition of S
#
# NB this stuff only works for partitions of subsets of \N.
                                     
#}}}
#{{{ static objects for testing

# static objects for testing
rel1:=rec();
rel1.indices:=[1,2,3,4];
rel1.asembedmatrix:=[[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]];
rel2:=rec();
rel2.indices:=[3,4,5,6];
rel2.asembedmatrix:=[[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,1,0,1,0],[0,0,0,1,0,1],[0,0,1,0,1,0],[0,0,0,1,0,1]];


#{{{ loop braid stuff

# want elementary transpos matrix for tensor space over dim d factors
ElemTrans:=function(n)
  # FINISHED! - seems to work.
  # USAGE: n=dim of tensor factor; returns n^2 elementary transpos matrix 
  local mat,i,j,k,l;
  mat:=NullMat(n*n,n*n);
  for i in [1..n] do
    for j in [1..n] do
      k:=n*(i-1)+j;
      l:=n*(j-1)+i;
      mat[k][l]:=1;
    od;
  od;
  return mat;
end;

#{{{ Braid and loop braid relation checks

BraidCheck:=function(a,b)
  # USAGE: a= R-matrix; b=tensor factor dimension, e.g. BraidCheck(looopg,6)
  # this checks the braid relation
  local gunk;
  gunk:=
  (KroneckerProduct(a,IdentityMat(b))*KroneckerProduct(IdentityMat(b),a)*KroneckerProduct(a,IdentityMat(b)) ) 
  - (KroneckerProduct(IdentityMat(b),a)*KroneckerProduct(a,IdentityMat(b))*KroneckerProduct(IdentityMat(b),a)); 
  return gunk;
end;
  
LoopBraidCheck:=function(a,t,b)
  # USAGE: a= R-matrix; t= another; b=tensor factor dimension, e.g. BraidCheck(looopg,6)
  # if t is the transposition
  # this checks the auto loop braid relation like a_1 t_2 t_1 = t_2 t_1 a_2
  # if a is the transposition this checks the welded LBR
  local gunk;
  gunk:=
  (KroneckerProduct(a,IdentityMat(b))*KroneckerProduct(IdentityMat(b),t)*KroneckerProduct(t,IdentityMat(b)) ) 
  - (KroneckerProduct(IdentityMat(b),t)*KroneckerProduct(t,IdentityMat(b))*KroneckerProduct(IdentityMat(b),a)); 
  return gunk;
end;
  
   
LoopBraidChuck:=function(a,t,b)
  # USAGE: a= R-matrix; t= another; b=tensor factor dimension, e.g. BraidCheck(looopg,6)
  # if t is the transposition
  # this checks the false loop braid relation like a_1 a_2 t_1 = t_2 a_1 a_2
  # if a is the transposition this checks the reverse auto LBR
  local gunk;
  gunk:=
  (KroneckerProduct(a,IdentityMat(b))*KroneckerProduct(IdentityMat(b),a)*KroneckerProduct(t,IdentityMat(b)) ) 
  - (KroneckerProduct(IdentityMat(b),t)*KroneckerProduct(a,IdentityMat(b))*KroneckerProduct(IdentityMat(b),a)); 
  return gunk;
end;
  
#}}}
#{{{ print nonzero entry positions of a matrix

PrintNonzeroEntries:=function(mat,n)
  # USAGE: PrintNonzeroEntries(square-matrix,size)  -- prints coords
  # and returns number of nonzero entries
  local i,j,k;
  k:=0;
  for i in [1..n] do
    for j in [1..n] do
      if mat[i][j]<>0 
         then Print(i," ",j,"  ") ;
         k:=k+1;  
       fi;
     od;
   od;
   return k;
 end;

#}}}

#{{{ 1.  S_3 tail rep

# see paper for more details
# NB IndentityMat(6)   

#{{{ towards loopg - full R-matrix (unfinished! zero version!)


# the ordered basis for kS_3 here (when it is done!) will be 
# {1,(12),(23),(13),(123),(132)}
# where 1 is the identity and the others are in cycle notation.

loopgzerotemplate:=[
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ,
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ,
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ,
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ,
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ,
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ];

# NB this is the zero matrix. Now read on.

#}}}
#{{{ loopg - full R-matrix (via loopgcheck)


# the ordered basis for kS_3 here (when it is done!) will be 
# {1,(12),(23),(13),(123),(132)}
# where 1 is the identity and the others are in cycle notation.

loopgcheck:=[
        [1,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,1,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,1,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,1,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,1,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,1, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ,
        [0,0,0,0,0,0, 1,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,1,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,1,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,1, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,1,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ,
        [0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,1,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,1,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,1, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,1,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ,
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,1,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,1,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,1, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,1,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ,
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,1,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,1,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,1,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,1, 0,0,0,0,0,0]
        ,
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,1,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,1,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,1,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,1,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,1]
        ];

# need to mult this by ElemTrans(6) to get real loopg

loopg:=loopgcheck*ElemTrans(6);

#}}}

#}}}
#{{{ 1.1 (12) bits

lopr:=[[1,0,0,0,0,0,0,0,0],
       [0,0,1,0,0,0,0,0,0],
       [0,1,0,0,0,0,0,0,0],
       [0,0,0,0,0,1,0,0,0],
       [0,0,0,0,1,0,0,0,0],
       [0,0,0,1,0,0,0,0,0],
       [0,0,0,0,0,0,0,1,0],
       [0,0,0,0,0,0,1,0,0],
       [0,0,0,0,0,0,0,0,1]];
        
lopt:=[[1,0,0,0,0,0,0,0,0],
       [0,0,0,1,0,0,0,0,0],
       [0,0,0,0,0,0,1,0,0],
       [0,1,0,0,0,0,0,0,0],
       [0,0,0,0,1,0,0,0,0],
       [0,0,0,0,0,0,0,1,0],
       [0,0,1,0,0,0,0,0,0],
       [0,0,0,0,0,1,0,0,0],
       [0,0,0,0,0,0,0,0,1]];

# TESTING: Can we build a rep of loop braid from this?
# The relations to check are: g1g2g1=g2g1g2  t1t2t1=t2t1t2  t1^2=1
#    g1t2t1 = 
# (where g1 = g \otimes 1 and g2 = 1 \otimes g  and so on).
# I computed  loprt:=lopr*lopt;  and then 
# gone:=KroneckerProduct(loprt,idthree);
# gtwo:=KroneckerProduct(idthree,loprt);
# (gtwo*gone*gtwo)-(gone*gtwo*gone);
#-- which is confirmed to be ZERO as required.
# NB
# LoopBraidCheck(ElemTrans(3),loprt,3);   is not zero.
# -the other three mixed checks all give zero.

#}}}
#{{{ 2.  Z_2 \ltimes Z_3 tail rep
#{{{ looopg = R-matrix for this case

# the ordered basis for k(Z_2 \ltimes Z_3) here is 
# {++,-+,+0,-0,+-,--}
# where Z_2 = {+,-} and Z_3 = {+1,0,-1}.

looopg:=[
        [1,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,1,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,1,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,1,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ,
        [0,1,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,1, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,1,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,1],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,1,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,1, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ,
        [0,0,1,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,1,0,0,0]
        ,
        [0,0,0,1,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,1,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,1,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,1,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,1,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,1,0,0]
        ,
        [0,0,0,0,1,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,1,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 1,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,1,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ,
        [0,0,0,0,0,1, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,1,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,1, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,1,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,1, 0,0,0,0,0,0],
        [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,1,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]
        ]; 

#}}}

#{{{ basis reordering moves

# note that the ordered basis of Z_2 \times Z_3 here 
# has different order to the S_3 example.
# the conversion matrix is something like:

reord:=[[0,0,1,0,0,0],
        [0,1,0,0,0,0],
        [0,0,0,0,0,1],
        [0,0,0,1,0,0],
        [1,0,0,0,0,0],
        [0,0,0,0,1,0]];

reordx:=KroneckerProduct(reord,reord);

rerd:=[[0,0,1,0,0,0],
       [0,1,0,0,0,0],
       [0,0,0,0,0,1],
       [0,0,0,1,0,0],
       [0,0,0,0,1,0],
       [1,0,0,0,0,0]];

rerdx:=KroneckerProduct(rerd,rerd);

# but note, exactly these do not convert between the two reps.
# neither do:

roerd:=[[0,0,1,0,0,0],
        [0,0,0,0,0,1],
        [0,1,0,0,0,0],
        [0,0,0,1,0,0],
        [1,0,0,0,0,0],
        [0,0,0,0,1,0]];

roerdx:=KroneckerProduct(roerd,roerd);

rord:=[[0,0,1,0,0,0],
        [0,1,0,0,0,0],
        [0,0,0,0,0,1],
        [0,0,0,1,0,0],
        [0,0,0,0,1,0],
        [1,0,0,0,0,0]];

rordx:=KroneckerProduct(rord,rord);

#}}}
#}}}

#}}}

#}}}


#{{{ local vars


# Local Variables:
# mode: Gap
# folded-file: t 
# fold-top-mark : "#{{{"
# fold-bottom-mark : "#}}}"
# End:

#}}}




